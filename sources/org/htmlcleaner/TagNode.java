package org.htmlcleaner;

import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import org.apache.commons.lang3.StringUtils;
import org.htmlcleaner.conditional.ITagNodeCondition;
import org.htmlcleaner.conditional.TagAllCondition;
import org.htmlcleaner.conditional.TagNodeAttExistsCondition;
import org.htmlcleaner.conditional.TagNodeAttValueCondition;
import org.htmlcleaner.conditional.TagNodeNameCondition;

public class TagNode extends TagToken implements HtmlNode {
    private Map<String, String> attributes;
    private boolean autoGenerated;
    private List children;
    private DoctypeToken docType;
    private transient boolean isFormed;
    private List itemsToMove;
    private Map<String, String> nsDeclarations;
    private TagNode parent;
    private boolean pruned;

    /* JADX INFO: super call moved to the top of the method (can break code semantics) */
    public TagNode(String str) {
        super(str == null ? null : str.toLowerCase());
        this.attributes = new LinkedHashMap();
        this.children = new ArrayList();
    }

    public String getAttributeByName(String str) {
        if (str != null) {
            return this.attributes.get(str.toLowerCase());
        }
        return null;
    }

    public Map<String, String> getAttributes() {
        return this.attributes;
    }

    public void setAttributes(Map<String, String> map) {
        this.attributes = map;
    }

    public boolean hasAttribute(String str) {
        if (str != null) {
            return this.attributes.containsKey(str.toLowerCase());
        }
        return false;
    }

    public void addAttribute(String str, String str2) {
        String str3;
        if (str != null) {
            String lowerCase = str.trim().toLowerCase();
            if (str2 == null) {
                str3 = "";
            } else {
                str3 = str2.trim().replaceAll("\\p{Cntrl}", StringUtils.SPACE);
            }
            if (lowerCase.length() != 0) {
                this.attributes.put(lowerCase, str3);
            }
        }
    }

    public void removeAttribute(String str) {
        if (str != null && !"".equals(str.trim())) {
            this.attributes.remove(str.toLowerCase());
        }
    }

    @Deprecated
    public List<TagNode> getChildren() {
        return getChildTagList();
    }

    /* access modifiers changed from: package-private */
    public void setChildren(List list) {
        this.children = list;
    }

    public List getAllChildren() {
        return this.children;
    }

    public List<TagNode> getChildTagList() {
        ArrayList arrayList = new ArrayList();
        for (Object next : this.children) {
            if (next instanceof TagNode) {
                arrayList.add((TagNode) next);
            }
        }
        return arrayList;
    }

    public boolean hasChildren() {
        return !this.children.isEmpty();
    }

    public TagNode[] getChildTags() {
        List<TagNode> childTagList = getChildTagList();
        TagNode[] tagNodeArr = new TagNode[childTagList.size()];
        for (int i = 0; i < childTagList.size(); i++) {
            tagNodeArr[i] = childTagList.get(i);
        }
        return tagNodeArr;
    }

    public CharSequence getText() {
        StringBuilder sb = new StringBuilder();
        for (Object next : this.children) {
            if (next instanceof ContentNode) {
                sb.append(((ContentNode) next).getContent());
            } else if (next instanceof TagNode) {
                sb.append(((TagNode) next).getText());
            }
        }
        return sb;
    }

    public int getChildIndex(HtmlNode htmlNode) {
        int i = 0;
        for (Object obj : this.children) {
            if (obj == htmlNode) {
                return i;
            }
            i++;
        }
        return -1;
    }

    public void insertChild(int i, HtmlNode htmlNode) {
        this.children.add(i, htmlNode);
    }

    public void insertChildBefore(HtmlNode htmlNode, HtmlNode htmlNode2) {
        int childIndex = getChildIndex(htmlNode);
        if (childIndex >= 0) {
            insertChild(childIndex, htmlNode2);
        }
    }

    public void insertChildAfter(HtmlNode htmlNode, HtmlNode htmlNode2) {
        int childIndex = getChildIndex(htmlNode);
        if (childIndex >= 0) {
            insertChild(childIndex + 1, htmlNode2);
        }
    }

    public TagNode getParent() {
        return this.parent;
    }

    public DoctypeToken getDocType() {
        return this.docType;
    }

    public void setDocType(DoctypeToken doctypeToken) {
        this.docType = doctypeToken;
    }

    public void addChild(Object obj) {
        if (obj != null) {
            if (obj instanceof List) {
                addChildren((List) obj);
            } else if (obj instanceof ProxyTagNode) {
                this.children.add(((ProxyTagNode) obj).getToken());
            } else {
                this.children.add(obj);
                if (obj instanceof TagNode) {
                    ((TagNode) obj).parent = this;
                }
            }
        }
    }

    public void addChildren(List list) {
        if (list != null) {
            for (Object addChild : list) {
                addChild(addChild);
            }
        }
    }

    private TagNode findElement(ITagNodeCondition iTagNodeCondition, boolean z) {
        TagNode findElement;
        if (iTagNodeCondition == null) {
            return null;
        }
        for (Object next : this.children) {
            if (next instanceof TagNode) {
                TagNode tagNode = (TagNode) next;
                if (iTagNodeCondition.satisfy(tagNode)) {
                    return tagNode;
                }
                if (z && (findElement = tagNode.findElement(iTagNodeCondition, z)) != null) {
                    return findElement;
                }
            }
        }
        return null;
    }

    public List getElementList(ITagNodeCondition iTagNodeCondition, boolean z) {
        List elementList;
        LinkedList linkedList = new LinkedList();
        if (iTagNodeCondition == null) {
            return linkedList;
        }
        for (Object next : this.children) {
            if (next instanceof TagNode) {
                TagNode tagNode = (TagNode) next;
                if (iTagNodeCondition.satisfy(tagNode)) {
                    linkedList.add(tagNode);
                }
                if (z && (elementList = tagNode.getElementList(iTagNodeCondition, z)) != null && elementList.size() > 0) {
                    linkedList.addAll(elementList);
                }
            }
        }
        return linkedList;
    }

    private TagNode[] getElements(ITagNodeCondition iTagNodeCondition, boolean z) {
        List elementList = getElementList(iTagNodeCondition, z);
        if (elementList == null) {
            return new TagNode[0];
        }
        return (TagNode[]) elementList.toArray(new TagNode[elementList.size()]);
    }

    public List getAllElementsList(boolean z) {
        return getElementList(new TagAllCondition(), z);
    }

    public TagNode[] getAllElements(boolean z) {
        return getElements(new TagAllCondition(), z);
    }

    public TagNode findElementByName(String str, boolean z) {
        return findElement(new TagNodeNameCondition(str), z);
    }

    public List getElementListByName(String str, boolean z) {
        return getElementList(new TagNodeNameCondition(str), z);
    }

    public TagNode[] getElementsByName(String str, boolean z) {
        return getElements(new TagNodeNameCondition(str), z);
    }

    public TagNode findElementHavingAttribute(String str, boolean z) {
        return findElement(new TagNodeAttExistsCondition(str), z);
    }

    public List getElementListHavingAttribute(String str, boolean z) {
        return getElementList(new TagNodeAttExistsCondition(str), z);
    }

    public TagNode[] getElementsHavingAttribute(String str, boolean z) {
        return getElements(new TagNodeAttExistsCondition(str), z);
    }

    public TagNode findElementByAttValue(String str, String str2, boolean z, boolean z2) {
        return findElement(new TagNodeAttValueCondition(str, str2, z2), z);
    }

    public List getElementListByAttValue(String str, String str2, boolean z, boolean z2) {
        return getElementList(new TagNodeAttValueCondition(str, str2, z2), z);
    }

    public TagNode[] getElementsByAttValue(String str, String str2, boolean z, boolean z2) {
        return getElements(new TagNodeAttValueCondition(str, str2, z2), z);
    }

    public Object[] evaluateXPath(String str) throws XPatherException {
        return new XPather(str).evaluateAgainstNode(this);
    }

    public boolean removeFromTree() {
        TagNode tagNode = this.parent;
        if (tagNode != null) {
            return tagNode.removeChild(this);
        }
        return false;
    }

    public boolean removeChild(Object obj) {
        return this.children.remove(obj);
    }

    public void removeAllChildren() {
        this.children.clear();
    }

    /* access modifiers changed from: package-private */
    public void addItemForMoving(Object obj) {
        if (this.itemsToMove == null) {
            this.itemsToMove = new ArrayList();
        }
        this.itemsToMove.add(obj);
    }

    /* access modifiers changed from: package-private */
    public List getItemsToMove() {
        return this.itemsToMove;
    }

    /* access modifiers changed from: package-private */
    public void setItemsToMove(List list) {
        this.itemsToMove = list;
    }

    /* access modifiers changed from: package-private */
    public boolean isFormed() {
        return this.isFormed;
    }

    /* access modifiers changed from: package-private */
    public void setFormed(boolean z) {
        this.isFormed = z;
    }

    /* access modifiers changed from: package-private */
    public void setFormed() {
        setFormed(true);
    }

    public void setAutoGenerated(boolean z) {
        this.autoGenerated = z;
    }

    public boolean isAutoGenerated() {
        return this.autoGenerated;
    }

    public boolean isPruned() {
        return this.pruned;
    }

    public void setPruned(boolean z) {
        this.pruned = z;
    }

    public boolean isEmpty() {
        if (isPruned()) {
            return true;
        }
        for (Object next : this.children) {
            if (next instanceof TagNode) {
                if (!((TagNode) next).isPruned()) {
                    return false;
                }
            } else if (!(next instanceof ContentNode)) {
                if (next instanceof CommentNode) {
                }
                return false;
            } else if (!((ContentNode) next).isBlank()) {
                return false;
            }
        }
        return true;
    }

    public void addNamespaceDeclaration(String str, String str2) {
        if (this.nsDeclarations == null) {
            this.nsDeclarations = new TreeMap();
        }
        this.nsDeclarations.put(str, str2);
    }

    /* access modifiers changed from: package-private */
    public void collectNamespacePrefixesOnPath(Set<String> set) {
        Map<String, String> namespaceDeclarations = getNamespaceDeclarations();
        if (namespaceDeclarations != null) {
            for (String add : namespaceDeclarations.keySet()) {
                set.add(add);
            }
        }
        TagNode tagNode = this.parent;
        if (tagNode != null) {
            tagNode.collectNamespacePrefixesOnPath(set);
        }
    }

    /* access modifiers changed from: package-private */
    public String getNamespaceURIOnPath(String str) {
        Map<String, String> map = this.nsDeclarations;
        if (map != null) {
            for (Map.Entry next : map.entrySet()) {
                String str2 = (String) next.getKey();
                if (str2.equals(str) || ("".equals(str2) && str == null)) {
                    return (String) next.getValue();
                }
            }
        }
        TagNode tagNode = this.parent;
        if (tagNode != null) {
            return tagNode.getNamespaceURIOnPath(str);
        }
        return null;
    }

    public Map<String, String> getNamespaceDeclarations() {
        return this.nsDeclarations;
    }

    public void serialize(Serializer serializer, Writer writer) throws IOException {
        serializer.serialize(this, writer);
    }

    public TagNode makeCopy() {
        TagNode tagNode = new TagNode(this.name);
        tagNode.attributes.putAll(this.attributes);
        return tagNode;
    }

    public void traverse(TagNodeVisitor tagNodeVisitor) {
        traverseInternally(tagNodeVisitor);
    }

    private boolean traverseInternally(TagNodeVisitor tagNodeVisitor) {
        if (tagNodeVisitor != null) {
            boolean z = this.parent != null;
            boolean visit = tagNodeVisitor.visit(this.parent, this);
            if (!visit) {
                return false;
            }
            if (z && this.parent == null) {
                return true;
            }
            for (Object obj : this.children.toArray()) {
                if (obj instanceof TagNode) {
                    visit = ((TagNode) obj).traverseInternally(tagNodeVisitor);
                } else if (obj instanceof ContentNode) {
                    visit = tagNodeVisitor.visit(this, (ContentNode) obj);
                } else if (obj instanceof CommentNode) {
                    visit = tagNodeVisitor.visit(this, (CommentNode) obj);
                }
                if (!visit) {
                    return false;
                }
            }
        }
        return true;
    }
}
